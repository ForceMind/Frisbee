<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>打飞盘 FPS — H5 原型 v4</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b1020; color: #e9ecf1; font-family: system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, Microsoft YaHei, Arial, sans-serif; }
    #wrap { position: relative; height: 100%; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

    /* HUD */
    .hud { position: absolute; left: 16px; top: 16px; display: grid; gap: 6px; user-select: none; pointer-events: none; }
    .pill { background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.15); padding: 8px 10px; border-radius: 10px; font-size: 14px; letter-spacing: .3px; }
    .row { display: flex; gap: 10px; align-items: center; }
    .key { display:inline-block; border: 1px solid rgba(255,255,255,.25); border-bottom-width: 2px; padding: 2px 6px; border-radius: 6px; font-size: 12px; }
    .hearts { font-size: 16px; letter-spacing: 2px; }
    .hearts .heart { color: #ff5a7d; text-shadow: 0 0 8px rgba(255,90,125,.35); }

    /* Center overlays */
    #menu, #pause, #gameover { position: absolute; inset: 0; display: none; place-items: center; background: radial-gradient(1200px 800px at 50% 50%, rgba(0,0,0,.55), rgba(0,0,0,.85)); }
    #menu { display:grid; }
    .card { width: min(92vw, 720px); background: rgba(16,20,40,.85); border: 1px solid rgba(255,255,255,.08); border-radius: 16px; padding: 22px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    h1 { margin: 0 0 6px; font-size: 28px; }
    p { margin: 6px 0; color: #c5cbda; }
    ul { margin: 8px 0 0 18px; color: #c5cbda; }
    .btns { margin-top: 14px; display:flex; gap: 10px; flex-wrap: wrap; }
    button { background: #3a7cff; color: white; border: 0; border-radius: 12px; padding: 10px 14px; font-weight: 600; letter-spacing: .3px; box-shadow: 0 6px 16px rgba(58,124,255,.36); cursor: pointer; }
    button.secondary { background: #2a2f45; box-shadow: none; }
    button:active { transform: translateY(1px); }

    /* Floating hit text */
    .float { position: absolute; transform: translate(-50%, -50%); color: #fff; font-weight: 700; text-shadow: 0 2px 8px rgba(0,0,0,.6); pointer-events:none; }

    /* Center banner */
    #banner { position:absolute; left:50%; top:12%; transform:translateX(-50%); pointer-events:none; }
    #banner .pill { font-size:16px; padding:10px 14px; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="pill hearts" id="lives">❤❤❤</div>
      <div class="pill" id="score">分数 0</div>
      <div class="pill" id="weapon">武器 M249</div>
      <div class="pill" id="level">难度 Lv.1</div>
      <div class="pill row" style="opacity:.85;">
        <span class="key">鼠标左键</span>射击
        <span class="key">R</span>换弹
        <span class="key">P</span>暂停
      </div>
    </div>

    <div id="banner"></div>

    <div id="menu">
      <div class="card">
        <h1>打飞盘 FPS</h1>
        <p>站桩瞄准，击落飞盘得分与连击，逐步解锁更强武器与更高难度。</p>
        <ul>
          <li>武器顺序：M249（连发） → M16（三连发） → M700（单发） → 格洛克（单发）</li>
          <li>命中心点（CENTER）分数更高；连击越高加分越多。</li>
          <li>早期（M249/M16）：飞盘更快更多；后期（M700/格洛克）：更慢更少。</li>
          <li>漏掉飞盘会扣生命，生命归零游戏结束。每累计得分可奖励生命。</li>
        </ul>
        <div class="btns">
          <button id="startBtn">开始游戏</button>
          <button class="secondary" id="howBtn">玩法说明</button>
        </div>
        <div id="how" style="display:none; margin-top:8px;">
          <p>左键射击；<strong>R</strong>换弹；<strong>P</strong>暂停。M16 需手动点击触发三连发。</p>
        </div>
      </div>
    </div>

    <div id="pause">
      <div class="card">
        <h1>已暂停</h1>
        <p>按 <span class="key">P</span> 继续游戏，或选择：</p>
        <div class="btns">
          <button id="resumeBtn">继续</button>
          <button class="secondary" id="restartBtn">重新开始</button>
        </div>
      </div>
    </div>

    <div id="gameover">
      <div class="card">
        <h1>游戏结束</h1>
        <p id="finalScore">你的得分：0</p>
        <div class="btns">
          <button id="retryBtn">再来一局</button>
          <button class="secondary" id="backBtn">返回主菜单</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  ;(() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const wrap = document.getElementById('wrap');

    // HUD
    const scoreEl = document.getElementById('score');
    const weaponEl = document.getElementById('weapon');
    const levelEl  = document.getElementById('level');
    const livesEl  = document.getElementById('lives');
    const banner   = document.getElementById('banner');

    // Overlays
    const menu = document.getElementById('menu');
    const pauseLayer = document.getElementById('pause');
    const gameoverLayer = document.getElementById('gameover');
    const finalScoreEl = document.getElementById('finalScore');

    // Buttons
    document.getElementById('startBtn').onclick = () => { ensureAudio(); startGame(); };
    document.getElementById('howBtn').onclick = () => {
      const how = document.getElementById('how');
      how.style.display = how.style.display === 'none' ? 'block' : 'none';
    };
    document.getElementById('resumeBtn').onclick = togglePause;
    document.getElementById('restartBtn').onclick = () => startGame(true);
    document.getElementById('retryBtn').onclick = () => startGame(true);
    document.getElementById('backBtn').onclick = () => { showMenu(); };

    // Resize
    function resize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width  = Math.floor(wrap.clientWidth * dpr);
      canvas.height = Math.floor(wrap.clientHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale to CSS pixels
    }
    window.addEventListener('resize', resize);
    resize();

    // Input
    let prevDown = false; // for edge detection
    const pointer = { x: canvas.width/2, y: canvas.height/2, down: false };
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      pointer.x = (e.clientX - rect.left);
      pointer.y = (e.clientY - rect.top);
    });
    canvas.addEventListener('mousedown', () => { ensureAudio(); pointer.down = true; });
    canvas.addEventListener('mouseup',   () => pointer.down = false);
    canvas.addEventListener('mouseleave',() => pointer.down = false);
    canvas.addEventListener('touchstart', e => {
      const t = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      pointer.x = (t.clientX - rect.left);
      pointer.y = (t.clientY - rect.top);
      pointer.down = true;
      ensureAudio();
      e.preventDefault();
    }, {passive:false});
    canvas.addEventListener('touchmove', e => {
      const t = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      pointer.x = (t.clientX - rect.left);
      pointer.y = (t.clientY - rect.top);
      e.preventDefault();
    }, {passive:false});
    canvas.addEventListener('touchend', () => pointer.down = false);

    window.addEventListener('keydown', (e) => {
      if (e.code === 'KeyR') reload();
      if (e.code === 'KeyP') togglePause();
    });

    // Game State
    let running = false, paused = false, intermission = false;
    let lastTime = 0; // ms
    let discs = [];
    let particles = [];
    let score = 0, combo = 0;
    let level = 1; // difficulty level
    let hitsTotal = 0;
    let lives = 3;

    // Combo grace: 允许间隔空枪不立刻断连
    let shotsSinceLastHit = 0;
    const COMBO_GRACE_SHOTS = 1; // 可改为2更宽容

    // Score-based life reward
    const LIFE_PER_POINTS = 20;   // 每累计20分+1生命
    const MAX_LIVES = 5;
    let nextLifeScoreStep = LIFE_PER_POINTS; // 下一个加命阈值

    // Audio (WebAudio) — created on first user gesture
    let audioCtx = null;
    function ensureAudio(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} } }
    function beep({freq=440, dur=0.06, type='square', gain=0.2}){
      if(!audioCtx) return;
      const t0 = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type; osc.frequency.value = freq;
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      osc.connect(g).connect(audioCtx.destination);
      osc.start(t0); osc.stop(t0+dur);
    }
    function noiseShot({dur=0.04, gain=0.22}){ // short white-noise burst
      if(!audioCtx) return;
      const sr = audioCtx.sampleRate; const length = Math.floor(sr*dur);
      const buffer = audioCtx.createBuffer(1, length, sr);
      const data = buffer.getChannelData(0);
      for(let i=0;i<length;i++){ data[i] = (Math.random()*2-1) * Math.exp(-i/ (length*0.6)); }
      const src = audioCtx.createBufferSource(); src.buffer = buffer;
      const g = audioCtx.createGain(); g.gain.value = gain;
      src.connect(g).connect(audioCtx.destination); src.start();
    }

    // Simple screenshake
    let shake = 0; function addShake(v){ shake = Math.min(shake + v, 12); }

    // Weapon visual recoil
    let recoilY = 0, recoilVel = 0; // for gun sprite
    function kickRecoil(strength){ recoilVel -= strength; }

    // Weapon definitions (names按你的修改)
    const Weapons = {
      M249: {
        id: 'M249', name: 'M249', points: 10, fireRate: 12, spread: 6, damage: 1,
        shot: fireHitscan, burst: 1, reloadTime: 0.8, mag: 40,
        recoil: 2.0, sfx: 'auto', spawnSpeedMul: 1.25, spawnCountBase: 3, requireEdge:false
      },
      M16: {
        id: 'M16', name: 'M16（三连发）', points: 15, fireRate: 4, spread: 4, damage: 1,
        shot: fireHitscan, burst: 3, burstGap: 60, reloadTime: 1.1, mag: 24,
        recoil: 2.6, sfx: 'burst', spawnSpeedMul: 1.15, spawnCountBase: 3, requireEdge:true // 需要点击触发
      },
      M700: {
        id: 'M700', name: 'M700', points: 25, fireRate: 1.2, spread: 1.2, damage: 1,
        shot: fireHitscan, burst: 1, reloadTime: 1.8, mag: 5,
        recoil: 4.0, sfx: 'bolt', spawnSpeedMul: 0.85, spawnCountBase: 1, requireEdge:false
      },
      GLOCK: {
        id: 'GLOCK', name: '格洛克', points: 20, fireRate: 2.4, spread: 1.5, damage: 1,
        shot: fireHitscan, burst: 1, reloadTime: 1.2, mag: 8,
        recoil: 1.6, sfx: 'pistol', spawnSpeedMul: 0.9, spawnCountBase: 1, requireEdge:false
      }
    };

    // Progress thresholds by total hits
    const progression = [
      { hits: 0,   weapon: Weapons.M249 },
      { hits: 25,  weapon: Weapons.M16 },
      { hits: 60,  weapon: Weapons.M700 },
      { hits: 90,  weapon: Weapons.GLOCK },
    ];

    let weapon = Weapons.M249;
    let bulletsInMag = weapon.mag;
    let fireCooldown = 0; // ms left for next shot
    let reloading = false;

    function showBanner(msg, ms=1500){
      banner.innerHTML = `<div class="pill">${msg}</div>`;
      banner.style.display = 'block';
      const anim = banner.firstElementChild.animate([
        { transform:'translateY(0)', opacity:0 },
        { transform:'translateY(6px)', opacity:1, offset:.2 },
        { transform:'translateY(0)', opacity:1, offset:.8 },
        { transform:'translateY(-6px)', opacity:0 }
      ], { duration: ms, easing:'ease-out' });
      anim.onfinish = () => { banner.style.display='none'; banner.innerHTML=''; };
    }

    function startIntermission(msg){
      intermission = true;
      discs = []; // 清屏
      showBanner(msg);
      setTimeout(()=>{ intermission = false; }, 1500);
    }

    function updateWeaponByHits() {
      for (let i = progression.length - 1; i >= 0; i--) {
        if (hitsTotal >= progression[i].hits) {
          const w = progression[i].weapon;
          if (weapon.id !== w.id) {
            weapon = w; bulletsInMag = weapon.mag; fireCooldown = 0; reloading = false;
            weaponEl.textContent = `武器 ${weapon.name}`;
            showBanner(`下一波：切换 ${weapon.name}`);
            intermission = true; // 中场不出飞盘
            setTimeout(()=>{ intermission = false; }, 1500);
          }
          break;
        }
      }
      // Level = 1 + floor(hitsTotal / 15)
      const newLv = 1 + Math.floor(hitsTotal / 15);
      if (newLv !== level) {
        level = newLv;
        levelEl.textContent = `难度 Lv.${level}`;
      }
      weaponEl.textContent = `武器 ${weapon.name}${reloading ? '（换弹中…）' : ''}`;
    }

    function reload() {
      if (reloading) return;
      if (bulletsInMag === weapon.mag) return;
      reloading = true;
      weaponEl.textContent = `武器 ${weapon.name}（换弹中…）`;
      setTimeout(() => {
        bulletsInMag = weapon.mag;
        reloading = false;
        weaponEl.textContent = `武器 ${weapon.name}`;
      }, weapon.reloadTime * 1000);
    }

    // Floating HUD messages
    function flashTop(text) {
      const el = document.createElement('div');
      el.className = 'pill';
      el.style.position = 'absolute';
      el.style.top = '16px';
      el.style.right = '16px';
      el.style.opacity = '0';
      el.textContent = text;
      wrap.appendChild(el);
      el.animate([
        { transform: 'translateY(0)', opacity: 0 },
        { transform: 'translateY(10px)', opacity: 1, offset: .2 },
        { transform: 'translateY(0)', opacity: 1, offset: .8 },
        { transform: 'translateY(-8px)', opacity: 0 }
      ], { duration: 1200, easing: 'ease-out' }).onfinish = () => el.remove();
    }

    function spawnFloatText(x, y, text) {
      const el = document.createElement('div');
      el.className = 'float';
      el.textContent = text;
      el.style.left = x + 'px';
      el.style.top  = y + 'px';
      wrap.appendChild(el);
      const dur = 800;
      el.animate([
        { transform:'translate(-50%, -50%)', opacity:1 },
        { transform:'translate(-50%, -90%)', opacity:0 }
      ], { duration: dur, easing: 'ease-out' }).onfinish = () => el.remove();
    }

    // Disc factory
    function spawnDisc() {
      const w = wrap.clientWidth, h = wrap.clientHeight;
      const edge = Math.floor(Math.random()*4);
      let x, y, vx, vy;
      const speedBase = (80 + level * 10) * (weapon.spawnSpeedMul || 1); // px/s depends on weapon
      const size = Math.max(16, 28 - Math.min(level, 10)) * (Math.random()*0.4+0.8); // base

      if (edge === 0) { x = Math.random()*w; y = -20; }
      if (edge === 1) { x = w+20; y = Math.random()*h; }
      if (edge === 2) { x = Math.random()*w; y = h+20; }
      if (edge === 3) { x = -20; y = Math.random()*h; }

      const tx = w*0.2 + Math.random()*w*0.6;
      const ty = h*0.2 + Math.random()*h*0.6;
      const ang = Math.atan2(ty - y, tx - x);
      const spd = speedBase * (Math.random()*0.5 + 0.8);
      vx = Math.cos(ang)*spd;
      vy = Math.sin(ang)*spd;

      const waveAmp = (level >= 3 ? (8 + Math.random()*18) : 0);
      const waveFreq = (level >= 3 ? (0.005 + Math.random()*0.015) : 0);

      discs.push({ x, y, r: size, vx, vy, life: 0, waveAmp, waveFreq, alive: true, hit:false });
    }

    function ensureSpawns(dt) {
      if (intermission) return; // 中场不刷盘
      // 基于武器阶段与生命数的数量平衡
      const baseWant = weapon.spawnCountBase; // 1~3
      let want = Math.min(baseWant + Math.floor(level/3), 6);
      if (lives === 2) want = Math.max(1, want - 1);
      if (lives === 1) want = Math.max(1, want - 2);
      if (discs.length < want) spawnDisc();
      let extra = (weapon.id==='M249'||weapon.id==='M16') ? 0.035 : 0.012;
      if (lives === 2) extra *= 0.8; if (lives === 1) extra *= 0.6;
      if (Math.random() < extra) spawnDisc();
    }

    // Shooting logic — hitscan under cursor with spread
    function tryShoot(dt) {
      if (!running || paused || reloading) return;
      fireCooldown -= dt; if (fireCooldown < 0) fireCooldown = 0;

      const wantFire = pointer.down;
      const edgeFire = wantFire && !prevDown; // 本帧按下沿
      prevDown = wantFire;

      const needEdge = !!weapon.requireEdge; // M16 需要点击触发
      const canTrigger = needEdge ? edgeFire : wantFire;

      if (!canTrigger || fireCooldown > 0) return;
      if (bulletsInMag <= 0) { reload(); return; }
      ensureAudio();

      const doOneShot = () => {
        const shots = weapon.burst || 1;
        let fired = 0;
        const burstGap = weapon.burstGap || 0; // ms per pellet
        const shootOne = () => {
          if (bulletsInMag <= 0) { reload(); return; }
          bulletsInMag--;
          // sfx + recoil + shake
          playShotSfx();
          kickRecoil(weapon.recoil||2);
          addShake((weapon.recoil||2)*0.7);
          // Spread point
          const spread = weapon.spread;
          const sx = pointer.x + (Math.random()*2-1)*spread;
          const sy = pointer.y + (Math.random()*2-1)*spread;
          weapon.shot(sx, sy);
          // 空枪计数（命中时会在fireHitscan里清零）
          shotsSinceLastHit++;
          fired++;
          if (fired < shots) setTimeout(shootOne, burstGap);
        };
        shootOne();
      };

      doOneShot();
      fireCooldown = 1000 / weapon.fireRate; // ms per trigger
    }

    function playShotSfx(){
      if(!audioCtx) return;
      switch(weapon.sfx){
        case 'auto': noiseShot({dur:0.05, gain:0.20}); beep({freq:180, dur:0.035, type:'square', gain:0.15}); break;
        case 'burst': noiseShot({dur:0.04, gain:0.18}); beep({freq:220, dur:0.04, type:'square', gain:0.16}); break;
        case 'bolt': noiseShot({dur:0.06, gain:0.25}); beep({freq:140, dur:0.06, type:'triangle', gain:0.18}); break;
        case 'pistol': noiseShot({dur:0.045, gain:0.19}); beep({freq:260, dur:0.04, type:'square', gain:0.14}); break;
        default: noiseShot({});
      }
    }

    function checkLifeReward(prevScore, newScore){
      // 每跨越20分台阶 +1 命
      while (newScore >= nextLifeScoreStep) {
        if (lives < MAX_LIVES) {
          lives++;
          updateLivesHUD();
          spawnFloatText(wrap.clientWidth*0.5, 100, '+1 生命');
          // 奖励音
          beep({freq:660, dur:0.08, type:'sine', gain:0.22});
          setTimeout(()=>beep({freq:880, dur:0.09, type:'sine', gain:0.22}), 70);
        }
        nextLifeScoreStep += LIFE_PER_POINTS;
      }
    }

    function fireHitscan(sx, sy) {
      // ellipse hit test (flattened frisbee)
      let hitIndex = -1; let bestDist = Infinity; let ellipseR = 0;
      for (let i = 0; i < discs.length; i++) {
        const d = discs[i];
        if (!d.alive) continue;
        const rx = d.r*1.1, ry = d.r*0.7; // ellipse radii
        const dx = d.x - sx, dy = d.y - sy;
        const norm = Math.hypot(dx/(rx), dy/(ry));
        const dist = norm * d.r;
        if (dist <= d.r && dist < bestDist) { bestDist = dist; hitIndex = i; ellipseR = d.r; }
      }
      crosshairPulse();

      if (hitIndex >= 0) {
        const d = discs[hitIndex];
        d.alive = false; d.hit = true;
        // 计分：中心命中加成更高（100%）+ 更强的连击加成
        const base = weapon.points;
        const centerHit = (bestDist <= ellipseR * 0.35);
        const centerBonus = centerHit ? Math.round(base * 1.0) : 0; // 100%
        // combo：每段 +12%（上限 +150%）
        combo = Math.min(combo + 1, 999);
        const comboBonus = Math.floor(base * Math.min(combo*0.12, 1.5));
        const gained = base + centerBonus + comboBonus;

        const prevScore = score;
        score += gained;
        hitsTotal += 1;
        scoreEl.textContent = `分数 ${score}`;
        // 清空空枪计数（击中）
        shotsSinceLastHit = 0;
        updateWeaponByHits();
        checkLifeReward(prevScore, score);

        // particles and float text
        spawnDiscPop(d.x, d.y, d.r, centerHit);
        const msg = `+${gained}${centerBonus>0?' CENTER!':''}${combo>1?` x${combo}`:''}`;
        spawnFloatText(d.x, d.y, msg);
        // hit sfx
        ensureAudio();
        beep({freq: 900, dur: 0.05, type: 'sine', gain: 0.2});
      } else {
        // 没击中：使用“空枪宽容”逻辑
        if (shotsSinceLastHit > COMBO_GRACE_SHOTS) combo = 0;
      }
    }

    // Particles
    function spawnDiscPop(x, y, r, center) {
      const n = 12 + Math.floor(Math.random()*8);
      for (let i=0;i<n;i++) {
        const ang = Math.random()*Math.PI*2;
        const spd = (center? 160:120) + Math.random()*80;
        particles.push({
          x, y,
          vx: Math.cos(ang)*spd/1000,
          vy: Math.sin(ang)*spd/1000,
          life: 0,
          ttl: 500 + Math.random()*300,
          size: Math.random()*2 + 1,
          col: center? '#ffd24d' : '#9ad1ff'
        });
      }
    }

    // Crosshair pulse state
    let crosshairScale = 1, crosshairAnim = 0;
    function crosshairPulse() { crosshairAnim = 1; }

    // Game loop
    function loop(ts) {
      if (!running) return;
      const dt = Math.min(34, ts - lastTime || 16); // ms
      lastTime = ts;

      if (!paused) {
        ensureSpawns(dt);
        update(dt);
        tryShoot(dt);
      }
      draw();
      requestAnimationFrame(loop);
    }

    function update(dt) {
      const w = wrap.clientWidth, h = wrap.clientHeight;
      for (const d of discs) {
        if (!d.alive) continue;
        d.life += dt;
        const t = d.life;
        const wx = d.waveAmp ? Math.sin(t * d.waveFreq) * d.waveAmp : 0;
        const wy = d.waveAmp ? Math.cos(t * d.waveFreq*0.8) * d.waveAmp*0.6 : 0;
        d.x += (d.vx/1000)*dt + wx*0.02;
        d.y += (d.vy/1000)*dt + wy*0.02;
        // out of bounds → miss
        if (d.x < -120 || d.x > w+120 || d.y < -120 || d.y > h+120) { d.alive = false; if(!d.hit) missDisc(); }
      }
      discs = discs.filter(d => d.alive);

      for (const p of particles) {
        p.life += dt;
        p.x += p.vx * dt * 60;
        p.y += p.vy * dt * 60;
      }
      particles = particles.filter(p => p.life < p.ttl);

      // recoil integration (simple spring)
      recoilVel += (0 - recoilY) * 0.02 * dt; // spring pullback
      recoilVel *= 0.92; recoilY += recoilVel * 0.06 * dt;

      // shake decay
      shake *= 0.92; if (shake < 0.3) shake = 0;
    }

    function draw() {
      const w = wrap.clientWidth, h = wrap.clientHeight;
      ctx.clearRect(0,0,canvas.width, canvas.height);
      // screenshake
      const sx = (Math.random()*2-1) * shake;
      const sy = (Math.random()*2-1) * shake;
      ctx.save(); ctx.translate(sx, sy);

      // sky gradient
      const grd = ctx.createLinearGradient(0,0,0,h);
      grd.addColorStop(0, '#0b1020');
      grd.addColorStop(1, '#111a33');
      ctx.fillStyle = grd;
      ctx.fillRect(0,0,w,h);

      // subtle horizon
      ctx.fillStyle = 'rgba(255,255,255,.03)';
      ctx.fillRect(0, h*0.72, w, 2);

      // discs (ellipses: flat frisbee)
      for (const d of discs) {
        const ry = d.r * (0.55 + 0.15*Math.sin(d.life*0.01));
        const rx = d.r * 1.1;
        // shadow
        ctx.beginPath();
        ctx.ellipse(d.x + rx*0.12, d.y + ry*0.25, rx*0.95, ry*0.95, 0, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,.25)';
        ctx.fill();
        // body
        const rim = ctx.createLinearGradient(d.x-rx, d.y-ry, d.x+rx, d.y+ry);
        rim.addColorStop(0, '#e8f3ff');
        rim.addColorStop(1, '#5fb1ff');
        ctx.beginPath(); ctx.ellipse(d.x, d.y, rx, ry, 0.35, 0, Math.PI*2);
        ctx.fillStyle = rim; ctx.fill();
        // center ring
        ctx.beginPath(); ctx.ellipse(d.x, d.y, rx*0.45, ry*0.45, 0.35, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,.55)'; ctx.lineWidth = 2; ctx.stroke();
      }

      // particles
      for (const p of particles) {
        const t = p.life / p.ttl;
        ctx.globalAlpha = 1 - t;
        ctx.fillStyle = p.col;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // crosshair
      if (crosshairAnim > 0) {
        crosshairAnim -= 0.1; if (crosshairAnim < 0) crosshairAnim = 0;
        crosshairScale = 1 + crosshairAnim*0.2;
      } else crosshairScale = 1;
      drawCrosshair(pointer.x, pointer.y, crosshairScale);

      // ammo indicator
      drawAmmo();

      // weapon sprite
      drawGun(w, h);

      ctx.restore();
    }

    function drawCrosshair(x, y, scale) {
      const r = 12 * scale;
      ctx.save();
      ctx.translate(x, y);
      ctx.strokeStyle = 'rgba(255,255,255,.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0,0,r,0,Math.PI*2);
      ctx.moveTo(-r-6,0); ctx.lineTo(-r+2,0);
      ctx.moveTo(r-2,0);  ctx.lineTo(r+6,0);
      ctx.moveTo(0,-r-6); ctx.lineTo(0,-r+2);
      ctx.moveTo(0,r-2);  ctx.lineTo(0,r+6);
      ctx.stroke();
      ctx.restore();
    }

    function drawAmmo() {
      const x = wrap.clientWidth - 20;
      const y = wrap.clientHeight - 20;
      const w = 130, h = 16;
      const ratio = bulletsInMag / weapon.mag;
      ctx.save();
      ctx.translate(x - w, y - h);
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#3a7cff';
      ctx.fillRect(0,0,Math.max(2, w*ratio), h);
      ctx.strokeStyle = 'rgba(255,255,255,.2)';
      ctx.strokeRect(0,0,w,h);
      ctx.fillStyle = '#e9ecf1';
      ctx.font = '12px system-ui, sans-serif';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';
      ctx.fillText(`${bulletsInMag} / ${weapon.mag}`, w-4, -2);
      ctx.restore();
    }

    function drawGun(w, h){
      // simple stylized gun at bottom-right; recoil moves it down/up
      const baseX = w - 220;
      const baseY = h - 120 + recoilY;
      ctx.save();
      ctx.translate(baseX, baseY);
      // hand
      ctx.fillStyle = '#d7b79a';
      ctx.fillRect(88, 52, 26, 26);
      // gun body differs a bit by weapon
      const primary = (weapon.id==='M700')? '#4a4f5e' : (weapon.id==='GLOCK')? '#394055' : '#2e3752';
      const accent  = '#6c86ff';
      // body
      ctx.fillStyle = primary; ctx.fillRect(0, 0, 160, 40);
      // grip
      ctx.fillStyle = '#1f2335'; ctx.fillRect(120, 40, 38, 40);
      // barrel
      ctx.fillStyle = '#8088a6'; ctx.fillRect(-40, 10, 40, 12);
      // sight
      ctx.fillStyle = accent; ctx.fillRect(20, -6, 16, 6);
      // highlights
      ctx.fillStyle = 'rgba(255,255,255,.15)'; ctx.fillRect(6,6,60,6);
      ctx.restore();
    }

    function updateLivesHUD(){
      livesEl.innerHTML = '<span class="heart">❤</span>'.repeat(Math.max(0,lives));
    }

    function missDisc(){
      combo = 0; shotsSinceLastHit = 0;
      lives = Math.max(0, lives - 1);
      updateLivesHUD();
      // fail sfx
      beep({freq: 160, dur: 0.12, type: 'sawtooth', gain: 0.2});
      // flash text middle-top
      spawnFloatText(wrap.clientWidth * 0.5, 60, '-1 生命');
      if (lives <= 0) gameOver();
    }

    function gameOver(){
      running = false; paused = false;
      finalScoreEl.textContent = `你的得分：${score}`;
      menu.style.display = 'none';
      pauseLayer.style.display = 'none';
      gameoverLayer.style.display = 'grid';
      // sfx
      beep({freq:120, dur:0.2, type:'triangle', gain:0.25});
    }

    function showMenu(){
      running = false; paused = false;
      menu.style.display = 'grid';
      pauseLayer.style.display = 'none';
      gameoverLayer.style.display = 'none';
    }

    function resetState() {
      discs = [];
      particles = [];
      score = 0; combo = 0; level = 1; hitsTotal = 0; lives = 3;
      shotsSinceLastHit = 0; nextLifeScoreStep = LIFE_PER_POINTS; intermission = false;
      weapon = Weapons.M249; bulletsInMag = weapon.mag; fireCooldown = 0; reloading = false;
      scoreEl.textContent = '分数 0';
      weaponEl.textContent = `武器 ${weapon.name}`;
      levelEl.textContent = '难度 Lv.1';
      updateLivesHUD();
      recoilY = 0; recoilVel = 0; shake = 0;
    }

    function startGame() {
      resetState();
      running = true; paused = false; lastTime = performance.now();
      menu.style.display = 'none';
      pauseLayer.style.display = 'none';
      gameoverLayer.style.display = 'none';
      requestAnimationFrame(loop);
    }

    function togglePause() {
      if (!running) return;
      paused = !paused;
      pauseLayer.style.display = paused ? 'grid' : 'none';
    }

    // Kickoff idle draw
    updateLivesHUD();
    draw();
  })();
  </script>
</body>
</html>